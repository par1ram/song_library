// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: songs_crud.sql

package database

import (
	"context"
	"database/sql"
)

const deleteSong = `-- name: DeleteSong :exec
DELETE FROM songs WHERE id = $1
`

func (q *Queries) DeleteSong(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteSong, id)
	return err
}

const getSongsFiltered = `-- name: GetSongsFiltered :many
SELECT id, song_name, release_date, text, link, group_id
FROM songs
WHERE ($1 IS NULL OR group_id = $1)
  AND ($2 IS NULL OR song_name ILIKE '%' || $2 || '%')
  AND ($3 IS NULL OR text ILIKE '%' || $3 || '%')
  AND ($4 IS NULL OR release_date = $4)
  AND ($5 IS NULL OR link ILIKE '%' || $5 || '%')
ORDER BY id
LIMIT $6 OFFSET $7
`

type GetSongsFilteredParams struct {
	Column1 interface{}
	Column2 interface{}
	Column3 interface{}
	Column4 interface{}
	Column5 interface{}
	Limit   int32
	Offset  int32
}

func (q *Queries) GetSongsFiltered(ctx context.Context, arg GetSongsFilteredParams) ([]Song, error) {
	rows, err := q.db.QueryContext(ctx, getSongsFiltered,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Song
	for rows.Next() {
		var i Song
		if err := rows.Scan(
			&i.ID,
			&i.SongName,
			&i.ReleaseDate,
			&i.Text,
			&i.Link,
			&i.GroupID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertSong = `-- name: InsertSong :one
INSERT INTO songs (group_id, song_name, release_date, text, link)
VALUES ($1, $2, $3, $4, $5)
RETURNING id
`

type InsertSongParams struct {
	GroupID     int32
	SongName    string
	ReleaseDate sql.NullTime
	Text        sql.NullString
	Link        sql.NullString
}

func (q *Queries) InsertSong(ctx context.Context, arg InsertSongParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertSong,
		arg.GroupID,
		arg.SongName,
		arg.ReleaseDate,
		arg.Text,
		arg.Link,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateSong = `-- name: UpdateSong :exec
UPDATE songs SET group_id = $2, song_name = $3, text = $4, release_date = $5, link = $6 WHERE id = $1
`

type UpdateSongParams struct {
	ID          int32
	GroupID     int32
	SongName    string
	Text        sql.NullString
	ReleaseDate sql.NullTime
	Link        sql.NullString
}

func (q *Queries) UpdateSong(ctx context.Context, arg UpdateSongParams) error {
	_, err := q.db.ExecContext(ctx, updateSong,
		arg.ID,
		arg.GroupID,
		arg.SongName,
		arg.Text,
		arg.ReleaseDate,
		arg.Link,
	)
	return err
}

const updateSongPartial = `-- name: UpdateSongPartial :exec
UPDATE songs
SET
    group_id = COALESCE($2, group_id),
    song_name = COALESCE($3, song_name),
    text = COALESCE($4, text),
    release_date = COALESCE($5, release_date),
    link = COALESCE($6, link)
WHERE id = $1
`

type UpdateSongPartialParams struct {
	ID          int32
	GroupID     int32
	SongName    string
	Text        sql.NullString
	ReleaseDate sql.NullTime
	Link        sql.NullString
}

func (q *Queries) UpdateSongPartial(ctx context.Context, arg UpdateSongPartialParams) error {
	_, err := q.db.ExecContext(ctx, updateSongPartial,
		arg.ID,
		arg.GroupID,
		arg.SongName,
		arg.Text,
		arg.ReleaseDate,
		arg.Link,
	)
	return err
}
